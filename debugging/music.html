<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
    <div>
        <audio id="bgm1" class="bgm" src="img/cypher.mp3" controls loop autoplay></audio>
    </div>
    <input id="upload" type="file" value="上传">
    <canvas id="myCanvas"></canvas>
</body>
<script>
    window.onload = function(){

        window.AudioContext= window.AudioContext||window.webkitAudioContext||window.mozAudioContext;
        window.RAF =  (function(){
                    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {window.setTimeout(callback, 1000 / 60); };
        })();
        var AC = new AudioContext();
        var analyser = new AnalyserNode(AC, {'fftSize': 2048})
        var canvas = document.getElementById("myCanvas"),
            ctx=canvas.getContext("2d");
        var upload = document.getElementById("upload");
        upload.onchange = function(){
            if(upload.files.length!==0){
                changeBuffer(upload.files[0]);
            }
        }

        function changeBuffer(file){
            var fr = new FileReader();
            fr.onload = function(e){
                var fileResult = e.target.result;
                AC.decodeAudioData(fileResult , function(buffer){
                    console.log(buffer);
                    playMusic(buffer)
                }, function(e){
                    console.log(e)
                    
                })
            }
            fr.readAsArrayBuffer(file);
        }
        
        function playMusic(arg) {
            var source;
            //如果arg是audio的dom对象，则转为相应的源
            if (arg.nodeType) {
                audioSource = audioSource || AC.createMediaElementSource(arg);
                source = audioSource;
            } else {
                bufferSource = AC.createBufferSource();

                bufferSource.buffer = arg;

                bufferSource.onended = function () {
                    app.trigger(singleLoop ? nowIndex : (nowIndex + 1));
                };

                //播放音频
                setTimeout(function () {
                    bufferSource.start()
                }, 0);

                source = bufferSource;
            }

            //连接analyserNode
            source.connect(analyser);

            //再连接到gainNode
            analyser.connect(gainnode);

            //最终输出到音频播放器
            gainnode.connect(AC.destination);
        }

        function Retangle(w, h, x, y) {
            this.w = w;
            this.h = h; //小红块高度
            this.x = x;
            this.y = y;
            this.jg = 3;
            this.power = 0;
            this.dy = y; //小红块位置
            this.initY = y;
            this.num = 0;
        };

        var Rp = Retangle.prototype;

        Rp.update = function(power){
            this.power = power;
            this.num = ~~(this.power / this.h + 0.5);

            //更新小红块的位置，如果音频条长度高于红块位置，则红块位置则为音频条高度，否则让小红块下降
            var nh = this.dy + this.h;//小红块当前位置
            if (this.power >= this.y - nh) {
                this.dy = this.y - this.power - this.h - (this.power == 0 ? 0 : 1);
            } else if (nh > this.y) {
                this.dy = this.y - this.h;
            } else {
                this.dy += 1;
            }

            this.draw();
        };

        Rp.draw = function(){
            ctx.fillStyle = grd;
            var h = (~~(this.power / (this.h + this.jg))) * (this.h + this.jg);
            ctx.fillRect(this.x, this.y - h, this.w, h)
            for (var i = 0; i < this.num; i++) {
                var y = this.y - i * (this.h + this.jg);
                ctx.clearRect(this.x - 1, y, this.w + 2, this.jg);
            }
            ctx.fillStyle = "#950000";
            ctx.fillRect(this.x, ~~this.dy, this.w, this.h);
        };

        function animate() {
            if(!musics[nowIndex].decoding){
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                //出来的数组为8bit整型数组，即值为0~256，整个数组长度为1024，即会有1024个频率，只需要取部分进行显示
                var array_length = analyser.frequencyBinCount;
                var array = new Uint8Array(array_length);
                analyser.getByteFrequencyData(array);    //将音频节点的数据拷贝到Uin8Array中

                //数组长度与画布宽度比例
                var bili = array_length / canvas.width;

                for (var i = 0; i < rt_array.length; i++) {
                    var rt = rt_array[i];
                    //根据比例计算应该获取第几个频率值，并且缓存起来减少计算
                    rt.index = ('index' in rt) ? rt.index : ~~(rt.x * bili);
                    rt.update(array[rt.index]);
                }

                copy();
            }else {
                showTxt("音频解码中...")
            }

            RAF(animate);
        }

        function copy() {
            var outctx = outcanvas.getContext("2d");
            var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height / 2);
            for (var i = 0; i < imgdata.data.length; i += 4) {
                imgdata.data[i + 3] = 30;
            }
            outctx.putImageData(imgdata, 0, 0);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(Math.PI);
            ctx.scale(-1, 1);
            ctx.drawImage(outcanvas, -canvas.width / 2, -canvas.height / 2)
            ctx.restore();
        }
    }   
</script>
</html>